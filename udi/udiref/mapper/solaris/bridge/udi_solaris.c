/*
 * File: mapper/solaris/bridge/udi_solaris.c
 *
 * Bridge mapper wrapper for Solaris 8.
 *
 */

/*
 * $Copyright udi_reference:
 * 
 * 
 *    Copyright (c) 1995-2001; Compaq Computer Corporation; Hewlett-Packard
 *    Company; Interphase Corporation; The Santa Cruz Operation, Inc;
 *    Software Technologies Group, Inc; and Sun Microsystems, Inc
 *    (collectively, the "Copyright Holders").  All rights reserved.
 * 
 *    Redistribution and use in source and binary forms, with or without
 *    modification, are permitted provided that the conditions are met:
 * 
 *            Redistributions of source code must retain the above
 *            copyright notice, this list of conditions and the following
 *            disclaimer.
 * 
 *            Redistributions in binary form must reproduce the above
 *            copyright notice, this list of conditions and the following
 *            disclaimers in the documentation and/or other materials
 *            provided with the distribution.
 * 
 *            Neither the name of Project UDI nor the names of its
 *            contributors may be used to endorse or promote products
 *            derived from this software without specific prior written
 *            permission.
 * 
 *    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *    "AS IS," AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *    HOLDERS OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 *    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 *    OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 *    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 *    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 *    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 *    DAMAGE.
 * 
 *    THIS SOFTWARE IS BASED ON SOURCE CODE PROVIDED AS A SAMPLE REFERENCE
 *    IMPLEMENTATION FOR VERSION 1.01 OF THE UDI CORE SPECIFICATION AND/OR
 *    RELATED UDI SPECIFICATIONS. USE OF THIS SOFTWARE DOES NOT IN AND OF
 *    ITSELF CONSTITUTE CONFORMANCE WITH THIS OR ANY OTHER VERSION OF ANY
 *    UDI SPECIFICATION.
 * 
 * 
 * $
 */

#include <sys/conf.h>
#include <sys/modctl.h>
#include <sys/stat.h>
#include <sys/ddi.h>
#include <sys/sunddi.h>
#include "udi_osdep.h"

/*
 * Generated by glue code for module
 * Note. We cannot #include <udi_env.h> as this conflicts with the iso std_arg
 * settings for va_arg, sigh. To avoid this we declare udi_init_info as an
 * extern int and pass the address of this as a void * to _udi_mapper_load
 */
extern _udi_sprops_idx_t	udi_udiMbrdg_sprops_idx[];
extern int			udi_init_info;		/* See Note above */

extern int _udi_mapper_load(const char *, void *, _udi_sprops_idx_t *);
extern int _udi_mapper_unload(const char *);

typedef struct soldrv_state {
	dev_info_t	*dip;
	void		*sprops;
	void		*init;
} soldrv_state_t;

static void	*_udi_soft_state;

static int
_udi_attach(dev_info_t *dip, ddi_attach_cmd_t cmd)
{
	int instance;
	soldrv_state_t	*statep;

	switch (cmd) {
	case DDI_ATTACH:
		cmn_err(CE_WARN, "_udi_attach(%p, DDI_ATTACH)\n", dip);
		instance = ddi_get_instance(dip);
		if (ddi_soft_state_zalloc(_udi_soft_state, instance) != 
					  DDI_SUCCESS) {
			return DDI_FAILURE;
		}
		/*
		 * Setup links in our soft-state structure, and link back to it
		 * in the devinfo_t
		 */
		statep = (soldrv_state_t *)ddi_get_soft_state(_udi_soft_state,
				instance);
		ddi_set_driver_private(dip, (caddr_t)statep);
		statep->dip = dip;
		statep->sprops = (void *)udi_udiMbrdg_sprops_idx;

		/*
		 * Report newly attached device
		 */
		ddi_report_dev(dip);
		return DDI_SUCCESS;
	default:
		return DDI_FAILURE;
	}
}

static int
_udi_detach(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
	int	instance;
	soldrv_state_t	*statep;

	switch (cmd) {
	case DDI_DETACH:
		instance = ddi_get_instance(dip);
		ddi_soft_state_free(_udi_soft_state, instance);
		return DDI_SUCCESS;
	default:
		return DDI_FAILURE;
	}
}

static int
_udi_getinfo(dev_info_t *dip, ddi_info_cmd_t cmd, void *arg, void **result)
{
	int	error = DDI_SUCCESS;
	int	instance;
	switch (cmd) {
	case DDI_INFO_DEVT2INSTANCE:
		instance = getminor((dev_t)arg);
		*result = (void *)instance;
		break;
	case DDI_INFO_DEVT2DEVINFO:
	default:
		error = DDI_FAILURE;
	}

	return (error);
}

/*
 * Character and device ops
 */
static struct cb_ops udi_cb_ops = {
	nodev,			/* open		*/
	nodev,			/* close	*/
	nodev,			/* strategy	*/
	nodev,			/* print	*/
	nodev,			/* dump		*/
	nodev,			/* read		*/
	nodev,			/* write	*/
	nodev,			/* ioctl	*/
	nodev,			/* devmap	*/
	nodev,			/* mmap		*/
	nodev,			/* segmap	*/
	nochpoll,		/* chpoll	*/
	nodev,			/* prop_op	*/
	NULL,			/* streamtab	*/
	D_MP | D_64BIT,		/* cb_flag	*/
	CB_REV,			/* cb_rev	*/
	nodev,			/* cb_aread	*/
	nodev			/* cb_awrite	*/
};

static struct dev_ops udi_dev_ops = {
	DEVO_REV,		/* devo_rev	*/
	0,			/* devo_refcnt	*/
	_udi_getinfo,		/* devo_getinfo	*/
	nodev,			/* devo_identify*/
	nulldev,		/* devo_probe	*/
	_udi_attach,		/* devo_attach	*/
	_udi_detach,		/* devo_detach	*/
	nodev,			/* devo_reset	*/
	&udi_cb_ops,		/* devo_cb_ops	*/
	NULL,			/* devo_bus_ops	*/
	nodev			/* devo_power	*/
};

/* modlinkage */
static struct modldrv udimodldrv = {
	&mod_driverops,
	"Solaris UDI Bridge Mapper",
	&udi_dev_ops
};
	
static struct modlinkage udimodlinkage = {
	MODREV_1,
	&udimodldrv,
	NULL
};

int
_init(void)
{
	int	error;

	ddi_soft_state_init(&_udi_soft_state, sizeof(soldrv_state_t), 0);
	error = mod_install(&udimodlinkage);

	if (error != 0) {
		/* Cleanup after failure */
		ddi_soft_state_fini(_udi_soft_state);
	} else {
		/* Load the mapper */
		error = _udi_mapper_load("udiMbrdg", (void *)&udi_init_info, 
					 udi_udiMbrdg_sprops_idx);
		if (error != 0) {
			cmn_err(CE_PANIC, "_udi_init failed");
			/* NOTREACHED */
		}
	}
	return (error);
}

int
_fini(void)
{
	int	error;

	error = mod_remove(&udimodlinkage);
	if (error == 0) {
		ddi_soft_state_fini(_udi_soft_state);
		error = _udi_mapper_unload("udiMbrdg");
	}
	return (error);
}

int
_info(struct modinfo *mip) {
	return mod_info(&udimodlinkage, mip);
}
