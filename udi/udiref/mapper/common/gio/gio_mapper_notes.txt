#
# File: mapper/common/gio/gio_mapper_notes.txt
#
# Kurt's vision on how GIO can be interfaced with an existing
# read/write/ioctl device driver model.
#

#
# $Copyright udi_reference:
# 
# 
#    Copyright (c) 1995-2001; Compaq Computer Corporation; Hewlett-Packard
#    Company; Interphase Corporation; The Santa Cruz Operation, Inc;
#    Software Technologies Group, Inc; and Sun Microsystems, Inc
#    (collectively, the "Copyright Holders").  All rights reserved.
# 
#    Redistribution and use in source and binary forms, with or without
#    modification, are permitted provided that the conditions are met:
# 
#            Redistributions of source code must retain the above
#            copyright notice, this list of conditions and the following
#            disclaimer.
# 
#            Redistributions in binary form must reproduce the above
#            copyright notice, this list of conditions and the following
#            disclaimers in the documentation and/or other materials
#            provided with the distribution.
# 
#            Neither the name of Project UDI nor the names of its
#            contributors may be used to endorse or promote products
#            derived from this software without specific prior written
#            permission.
# 
#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#    "AS IS," AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#    HOLDERS OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
#    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
#    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
#    OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
#    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
#    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
#    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
#    DAMAGE.
# 
#    THIS SOFTWARE IS BASED ON SOURCE CODE PROVIDED AS A SAMPLE REFERENCE
#    IMPLEMENTATION FOR VERSION 1.01 OF THE UDI CORE SPECIFICATION AND/OR
#    RELATED UDI SPECIFICATIONS. USE OF THIS SOFTWARE DOES NOT IN AND OF
#    ITSELF CONSTITUTE CONFORMANCE WITH THIS OR ANY OTHER VERSION OF ANY
#    UDI SPECIFICATION.
# 
# 
# $
#

Here are some brief notes on how I see read/write/ioctl being mapped to
GIO operations in a generic GIO mapper.

-----------------------------------------------------------------------
Kurt Gollhardt             email: kdg@sco.com    voice: +1 908 790 2277
SCO Core OS Architect      Murray Hill, NJ       fax:   +1 908 790 2426
-----------------------------------------------------------------------

The read() system call maps to udi_gio_xfer_op with UDI_GIO_OP_READ.

The write() system call maps to udi_gio_xfer_op with UDI_GIO_OP_WRITE.

The ioctl() system call maps to udi_gio_xfer_op for custom ops, by
decoding the low 32 bits of "cmd" arg as follows:

	upper 1 bit: set to one to distinguish from other ioctls
	next 10 bits: op (of which high 2 bits is data_dir)
	next 5 bits: inline_type [see below]
	low 16 bits: payload_size

Presumably, there'd be a macro to construct the above value from op,
inline_type, and payload_size.

The "arg" arg points to a user data buffer. The first payload_size
bytes are used as the contents of the data_buf, with data_len set to
payload_size. The next inline_size bytes (starting at a sizeof(long)
boundary) of this buffer become the inline data for tr_params. (The
inline_size value is derived from inline_type as described below.)

The read/write/ioctl are synchronous; i.e. they wait for the
corresponding ack or nak. Therefore, udi_gio_abort is not supported by
this mapper.

The read/write/ioctl system call shall return EIO if a udi_gio_xfer_nak
is rcvd instead of udi_gio_xfer_ack.

TBD: What to do with status code from udi_gio_xfer_nak in this case?
Stuff it at the front or end of the user data buffer?

Other ioctl cmd values are relative to the following base value:

	#define GIO_IOC	('G'<<24 + 'I'<<16 + 'O'<<8)

	#define GIO_IOC_INLINE_TYPE	(GIO_IOC + 1)

GIO_IOC_INLINE_TYPE is used to defined an inline "type"; this maps a
5-bit number to an (inline_size, inline_layout) pair. The "arg" arg
is a pointer to the following struct:

	typedef struct {
		udi_ubit8_t	inline_type;
		udi_ubit8_t	inline_size;
		udi_ubit8_t	inline_layout[1];	/* variable-size */
	} gio_inline_type_t;

TBD: Are these the right data types? How do we get these data types
and the UDI_DL_xxx defines exposed to an application without pulling
in all the rest of udi.h?

Note: This violates the spirit of the spec, since the mapper would rcv
these dynamically and would not be able to call udi_gio_xfer_cb_init
from its init_module(). The mapper can of course reach under the cover
to do this, so it will work, but...

-----------------------------------------------------------------------
