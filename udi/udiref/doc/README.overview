# File: doc/README.overview
#
# Source/Project Overview document from Prototyping effort.  Should be
# moved to udirefweb doc pages in the future...
# 


-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0
$Copyright udi_reference:


   Copyright (c) 1995-2001; Compaq Computer Corporation; Hewlett-Packard
   Company; Interphase Corporation; The Santa Cruz Operation, Inc;
   Software Technologies Group, Inc; and Sun Microsystems, Inc
   (collectively, the "Copyright Holders").  All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the conditions are met:

           Redistributions of source code must retain the above
           copyright notice, this list of conditions and the following
           disclaimer.

           Redistributions in binary form must reproduce the above
           copyright notice, this list of conditions and the following
           disclaimers in the documentation and/or other materials
           provided with the distribution.

           Neither the name of Project UDI nor the names of its
           contributors may be used to endorse or promote products
           derived from this software without specific prior written
           permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS," AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   HOLDERS OR ANY CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
   BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
   OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
   TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
   DAMAGE.

   THIS SOFTWARE IS BASED ON SOURCE CODE PROVIDED AS A SAMPLE REFERENCE
   IMPLEMENTATION FOR VERSION 1.01 OF THE UDI CORE SPECIFICATION AND/OR
   RELATED UDI SPECIFICATIONS. USE OF THIS SOFTWARE DOES NOT IN AND OF
   ITSELF CONSTITUTE CONFORMANCE WITH THIS OR ANY OTHER VERSION OF ANY
   UDI SPECIFICATION.


$
-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0-0

  intro
  history 
  community
     lists
     players
  code management
     remote cvs
     commit early, often
     good changelogs
  directory layout
     env/common
  configuration/build
  osdep macros, functions
  code
    tools
    env
    mappers
    pseudo
  posix
  bringup procedure
    pseudod
    cmos (for PC platforms)
    pseudond
    dpt/shrk


This document describes the UDI reference port.  It it targeted toward
environment implementors and developers of that code.  A basic knowledge
of the UDI specifications is assumed.

[ TODO: reference history in UDI white paper, URL ] 
The UDI specification grew over a number of years. The UDI prototype
has grown with it. About 1995 or 1996 a number of the active members
recognized the need for a vehicle to implement the spec. The original
UDI prototyping effort started around version 0.75 or 0.77 of the
spec. Issues exposed by this effort were then folded into 0.80 of
the UDI specification. As part of this original prototyping phase,
environments were available for HP-UX, Digital UNIX, SCO UnixWare, SCO
OpenServer, and NCR's MP-RAS. A Linux environment was added late in
the effort. Drivers were written for the Adaptec 2940 family of SCSI
HBAs and the InterPhase IPU5524 NIC. Not all environments provided
support for all drivers, but coverage of several diverse OS and
hardware architectures helped validate the spec. This effort focused on
validing core UDI concepts such as inter-module communication, and the
metalanguage/environment interface. Little attention was given to issues
like packaging, distribution of UDI drivers, binary interoperability,
or similar issues needed for a "production quality" implementation. As
a result of this effort, changes in the spec were proposed but the code
languished for about a year.

In January of 1999, a new team was formed to revive the prototyping
effort and to resync it to the then-current 0.86 version of the spec.
This group was mostly SCO staff so UnixWare 7 was the target OS. It was
a goal to use the earlier prototyping effort, but to improve on it in
many ways as well as to expand it for the growing specification. For
example, the 0.80 prototype duplicated much code on a per-OS basis.
Improving the commonality of the code base was a goal. There was also
much new code to be implemented such as static driver properties, the
packaging tools, and the new PIO system. By August we had several
functioning drivers, including one HBA, for select members of the DPT
SmartCACHE and SmartRAID. By December we had a functioning NIC driver
(for the Osicom 2300 NIC) and mapper. 

January, 2000 welcomed successful I/O on the Adaptec controllers and
the bringup of the SCO OpenServer environment. Independent hardware
vendors have successfully used the development kit from SCO to develop
both NIC and SCSI drivers.  Most of 2000 was consumed by implementing
and validating the 1.01 specification and finishing up a product-quality
source base.  The code was QA'ed at several large organizations for
specific hardware and driver mixes.

In early 2001, we cleared the remaining technical and legal hurdles
and released the source code publicly under a BSD-style license on
projectudi.sourceforge.net.


CODE MANAGEMENT

The udiref tree is managed by CVS on the SourceForge system hosted by VA
Linux at http://projectudi.sourceforge.net.

We encourage frequent and small patch submissions over large ones. This
simplifies pinpointing problems that may get introduced and makes it
easy to roll independent changes back. If your work is likely to be
disruptive to others, we ask that you do it on a branch. This allows
the benefits of peer review and testing on systems that you may not
have while keeping the "top of tree" developers insulated from the
turbulence.

The build tree makes extensive use of ISO C and the use of "traditional"
tools found on a UNIX system (shell scripts, awk, make) is allowed.
Of course, use of vendor extensions in common code is unacceptable
since the same code runs on a wide variety of hosts. With system-
level programming such as this, sometimes unportable constructs will be
necessary. These should be confined to the OS-specific macros and files.

All code committed in common area should be exercised on at least one
and preferably two different environments. Code should be committed
atomically when possible. For example, if you add code that uses and
defines a new structure member, please commit the .c and the .h files
at the same time. Otherwise people updating between the commits will be
unable to compile. Care should be taken to keep the tree compiling and
working at all times. From time to time, disruptive changes on the trunk
may be necessary but these should be announced before-hand. Also a CVS
tag (or branch) should be applied to the tree so that others can choose
to stay out of the turbulence.

The use of descriptive CVS commit logs is encouraged.  Obviously trivial
changes don't need lengthy descriptions, but a brief summary of what you
changed and why is in order.  This helps others identify recent changes.

DIRECTORY LAYOUT

The udiproto tree is broken into a number of directories to separate
the various systems. It is a goal to be able to type 'make' at the top
level and have a complete build performed on all systems. We encourage a
"README" in each directory to describe the contents of that directory.

  doc/ various internal documentation.
  driver/* one directory per driver.  Not all drivers will be applicable
 	to all systems.  Even highly instrumented drivers used only for
	testing that should probably never be distributed will go into
	this directory.   
  env/ the UDI environment.
  env/common/ The portable part of the core environment.
  env/OSNAME/ Any env files specific to an OS.  These might define C 
	compiler options, interfaces to the native OS, and pieces of
  	the common code that are just too system-specific to do via 
	macros.  (Physio spec has several such occurrences.)
  env/OSNAMEstub/ files needed for a POSIX implementation on a given
	OS.   See the section on the POSIX environment for more details.
	DEPRECATED.
  env/OSNAME-user/ Files for the user-space UDI environment and used with
	the newer POSIX test tools.

  mapper/ Mappers typically speak UDI on one end and "native" OS interface
	on another.
  mapper/common/ The portable part of the mappers.
  mapper/OSNAME/ The part of the mappers that are OS-specific.
  mapper/OSNAME/META The implementation of the meta-language component of
	the mapper for each metalanguage spoken.   For example, 
	mapper/uw/net contains the UnixWare networking mapper that 
	includes the mapper/common/net networking code to handle the
	shared sevices.
  meta/META/ The metalanguages defined by the spec.   These are 
	OS-independent and define the set of channel ops supported by
	any UDI metalanguage.
  tests/OSNAME/ Optional collections of test programs that an implementor
	can use to exercise the environment.  Ideally, regression tests 
	would be stored here.
  package/OSNAME/ Optional tools to control and exercise packaging of
	distributions. 
  pub_include/  The definitions and prototypes of the UDI specification 
	that are meant to be visible to users of that spec.  Changes
	here must be very carefully checked against the specification.
	The directory and filename layout is chosen to map tightly to 
	the actual specs.
  tools/ The UDI packaging and distribution tools.
  tools/common/ The portable component of the tools.
  tools/OSNAME/ Any OS-specific files for the tools.


CONFIGURATION AND BUILD.

The UDI prototype tree is designed to be built from the top level,
although builds from lower levels are acceptible as well.  From the
top of the tree, simply type "$ make" and the build should walk all
the appropriate directories and do the appropriate things.

There are also "clean" and "install" targets for make that either
remove the built objects from the tree or install the objects onto the
currently running system, respectively.

Older versions of the tree may require GNU make due to the complexity
of the make scheme.  Newer versions of the tree rely more heavily on
the UDI tools to perform the build operations and the make scheme is
much simpler and should be functional for most if not all make
utilities.


OS-DEPENDENT Macros and functions.

There is a large amount of common code, but ultimately it has to be
connected to OS services.   For example, most OSes provide a differing
interface to the memory allocator or threads manipulation facilities.
In udiproto, these are known as "osdep" hooks.

Through the common code, you will find OSDEP macros used to access such
services. These are typically defined in your OSNAME/udi_osdep.h. Not
all such macros have to be provided. Default values and documentation
are provided in common/udi_osdep_defaults.h. Of key importance are the
mutexes and the memory allocation services. These will be needed early
in the development of the environment. The UDI Environment Implementors
provides guidelines on implementing these and related services.

Sometimes an OSDEP service is too complicated or too large to provide
as a C macro.   When this occurs, just provide an appropriate function
to do the work and make the OSDEP macros call it.

TOOLS

The build procedure is quite dependent upon udibuild, udisetup, and
udimkpkg as described in the UDI specification.  So porting these tools
will likely be an early task in providing an environment.

The tools have been designed with similar portability concerns as the
UDI environment and mapper implementations.  Typically, just a few
files are needed in the OS-specific subdirectory in the tools
heirarchy and common code will do the rest.  The best way to begin a
tools port is to copy an existing directory for an OS that's fairly
close to the target OS.

XXX Details on
  * object file manipulations/ relation to static driver props/ ABI.
  * output file (i.e. UW DSP, packaging) requirements.
  * interfacing with PAX-er.
  * compilation system interface.

ENVIRONMENT

An implementation that doesn't support the Physical I/O services can
have a very simple OS-dependent component of the environment. The pieces
that are most needed are the mutual exclusion primitives, the memory
allocation daemon, and the static driver properties. We provide a few
pseudo-drivers that use no physicial hardware to allow you to exercise
those core services before actual hardware is involved. Of course,
a driver infrastructure that doesn't support physio is of limited
'real-world' use, so adding support for DMA, PIO, and interrupts should
probably follow closely.


MAPPERS

UDI provides several metalanguages. You will need to implement a mapper
for each that you wish to support. In a layered implementation, where
UDI drivers are atop a native driver interface, one side of the mapper
will speak the native interface for mass storage, networking, and so on
while the other side of the mapper will speak UDI. With some care, these
can have lightweight runtime costs (no data copies, etc.) but do have to
get extensively involved in the "plumbing" of the drivers as they have
to map events from native model to UDI model. Using common code, when
available, is a good idea as that largely provides the UDI half of the
equation.

GIO, the Generic I/O metalanguage, is typically implemented as a UNIX
character driver.   There are guidelines in that directory for ioctl
interfaces to that driver.   The traditional read and write interfaces
should also be supplied.

TODO: SCSI mappers.

TODO: Net mappers.


POSIX

One interesting debugging facility is the ability to run the UDI
environment and many drivers as user-level applications. We've taken
the core environment and written a user-space environment
implementation that uses common application and library interfaces.
For example, it uses 'malloc' to get memory instead of calling a
kernel memory allocator.

This approach has a number of benefits to the developer, but it also
has a few limitations. While tools like source level debuggers,
instrumented memory allocators, bounds checkers, and fast crash recovery
are available, the ability to talk to real hardware is often limited.
Some OSes may provide (to superuser processes) a limited ability to run
such programs. Even without this ability, many facilities like channel
operations, core inter-module communications, memory allocations, can
often be debugged in this way.

The core code and various test programs are provided in env/posix. To
configure the environment, go to the posix directory (or a parallel
copy thereof), run 'configure' and build the code with make (this
should be done *after* a make from the top of the tree).  Make targets
include 'check' which runs all the available tests with a limited
degree of instrumentation and 'torture' which runs all the available
tests with all forms of instrumentation. The exact features exercised
will vary from host to host, but might include tests such as binding a
driver and running GIO to a pseudo driver while failing all memory
allocations, queueing all channel ops, reallocating all control blocks
on each op, and simulating that all target regions of am mei call are
busy. It may also do all this while trapping null pointer dereferences
and running the memory allocators so that buffers end (or begin) on
page boundaries adjacent to unmapped pages so that buffer bounds
violations can be quickly detected.

A 'make torture' before commits provides an important baseline for the
code stability. It exercises over 75% of the code in env/common so it
is a good sanity check for new work. It also provides a vehicle so that
developers on one OS can create small test cases that show a problem on
other OSes for additional help.

BRINGUP PROCEDURE

When porting all this code to a new target, here is a suggested ordering
for bringing the code up. It will hopefully help describe potential
parallelism opportunities if you have multiple programmers working
on the project simultaneously. Even though some of the code isn't
cost-effective to share between OSes, you'll often find the environments
are similar enough to allow for substantial "borrowing" between them.

First, bring up the tools. The sample drivers and the mappers both need
to be built as standard UDI drivers because they contain udiprops.txt
images that need to be "branded" into the binary in a way appropriate
for the ABI of your target platform. Focus first on udibuild, then
udimkpkg as these are responsible for invoking the compiler and
generating compliant packages. Then move to udisetup. Udisetup contains
much OS-dependent code because it has to intimately know how to handle
the details of things like installing a network driver into the host
OS. These service are well outside the domain of standards such as
POSIX 1003.1 or Unix 98. Verify that all the provided drivers build
and hand-inspect the resulting packages and executables contain no
references non-conforming symbols.

Next comes core environmental services in env. You have to provide
appropriate definitions for things like system locks, memory
allocations. In the early days, you can defer things like readable files
and physical I/O. This is also a good point to write a GIO mapper. In
most OSes, this can be a simple character driver.

The `pseudod' driver lets you exercise complete character I/O paths
without any physical I/O. It provides a driver that generates a
test pattern when read. It is a reasonable way to exercise the core
functionality of the environment without introducing dependencies on
services like the bridge mapper, interrupts, and DMA. It has the added
benefit that in most OSes, the needed GIO mapper is very simple.

The `udi_cmos' driver makes a good first physical I/O driver on a PC
platform. It does contain a few kinks because it uses a bus binding
that isn't yet codified in official UDI doctrine. For example, since
the CMOS clock has no PCI, the bridge mapper may have to magically
instantiate the driver and the PIO code mae have to divine the address
of the device. (Since it's at the same address for every PC in the last
two decades, this is not as unreasonable at it sounds.) This gives the
environment implementor a chance to exercise simple PIO and most of the
code paths in the bridge mapper.

Once you've written a mapper for the networking metalanguage, use the
`pseudond' driver to exercise it. This is a simple network driver that
touches no physical hardware and implements a NIC that provides simple
networking loopback. It allows you to test the paths that the main tx
and rx code paths and things like MAC address setting, counters, and
such.

A disk storage (SCSI) mapper is typically needed. There isn't a
hardware-less driver for the storage meta at this time, so you'll have
to implement and test the mapper in conjunction with one of the drivers.

Once physical I/O (PCI enumeration, interrupts, DMA, and physical I/O)
are coded, you can now stir in one of the "real" drivers such as the
Adaptec or DPT SCSI HBAs or the Osicom 2300 NIC driver, and have real
results.


There are also a few hazards to think about.   When doing the UnixWare
environment, here were some of the beasts we had to slay:
   * Initial System Load with UDI HBA to a disk or from a CD.   This
     had a few challenges because we needed it to work with existing OS 
     CDs so we were somewhat limited in what code we could change. It 
     also turned out this exposed some stress problems in early days of
     our environment.   We also ran into problems because we had been
     letting udisetup write the "glue" code as C.  While we always have a 
     compiler at runtime, it's not available at boot time for initial 
     system load.   So we had to write the glue directly into the ELF
     objects.   
   * Initial system load from UDI NIC.
   * Dump device.   When performing a system dump, interrupts and timers
     may be unavailable.   So capturing a panic requires some special 
     consideration.
   * Readable files and message files.   These may be called at inconvenient
     times such as within interrupt context. (yikes!)   Also some systems
     may not have convenient facilities to read files from withing the kernel
     so you may have to suck them into the kernel staticly at udisetup time.
   * Full device Hot plug.  'Nuff said.
   * Hot add of devices.   For example, if an external tape drive is turned
     off when the MA enumerates the HBA, how do you force the HBA to enumerate
     the drive?   UW and Linux have facilities (`sdiconfig' and `echo 
     "scsi add-single-device 0 0 6 0" >/proc/scsi/scsi', respectively) to do
     that and it would be nice for UDI drivers to look the same.

   * [ what else? ] 


